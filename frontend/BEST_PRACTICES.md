# üéØ MEJORES PR√ÅCTICAS: Next.js + Zustand + Server Actions

## üìä Comparaci√≥n: React/Vite vs Next.js

### ‚ùå Enfoque anterior (React/Vite)
```jsx
// ‚ùå Fetch directo en el componente (inseguro)
const fetchAvailableTimes = async (selectedDate) => {
  const response = await fetch(
    `https://api.com/appointments/available?selectedDate=${formattedDate}`
  );
  const data = await response.json();
  setAvailableTimes(data.availableTimes || []);
};

// ‚ùå Props drilling
<CalendarWithTimes 
  formData={formData} 
  setFormData={setFormData} 
  isFormData={isFormData} 
  setIsFormData={setIsFormData} 
/>
```

### ‚úÖ Enfoque actual (Next.js + Zustand)
```tsx
// ‚úÖ Server Action (seguro, sin exponer API al cliente)
"use server"
export async function obtenerHorariosDisponibles(fecha: string) {
  const response = await fetch(`https://api.com/appointments/available?selectedDate=${fecha}`);
  return await response.json();
}

// ‚úÖ Zustand (estado global, sin props drilling)
const formData = useFormStore((state) => state.formData);
const setAppointment = useFormStore((state) => state.setAppointment);
```

---

## üèóÔ∏è ARQUITECTURA RECOMENDADA

### 1Ô∏è‚É£ **Server Actions (app/actions/)**
**Prop√≥sito:** L√≥gica de servidor, fetch a APIs, base de datos

```typescript
// ‚úÖ DO: Funciones puras para Server Actions
"use server";

export async function obtenerHorariosDisponibles(fecha: string): Promise<string[]> {
  const response = await fetch(`https://api.com/...`, {
    next: { revalidate: 30 } // Cache inteligente
  });
  return response.json();
}

// ‚úÖ DO: Helpers s√≠ncronos NO necesitan "use server"
export function calcularRangoHorarios(hora: string, duracion: number): string[] {
  // C√°lculo s√≠ncrono
  return ["09:00", "09:15", "09:30"];
}
```

**‚ùå DON'T:**
```typescript
// ‚ùå No mezclar l√≥gica de UI en Server Actions
// ‚ùå No usar hooks de React aqu√≠
// ‚ùå No hacer "use server" en funciones que no hacen I/O
```

---

### 2Ô∏è‚É£ **Zustand Store (hooks/useFormStore.ts)**
**Prop√≥sito:** Estado global compartido entre p√°ginas

```typescript
// ‚úÖ DO: Usar selectores para mejor performance
const formData = useFormStore((state) => state.formData);
const setAppointment = useFormStore((state) => state.setAppointment);

// ‚ùå DON'T: Extraer todo el store (causa re-renders innecesarios)
const { formData, setAppointment, ...otherStuff } = useFormStore();
```

**Cu√°ndo usar Zustand:**
- ‚úÖ Datos compartidos entre m√∫ltiples p√°ginas (formulario multi-paso)
- ‚úÖ Datos que necesitas persistir (localStorage)
- ‚úÖ Estado que necesita actualizarse desde varios lugares

**Cu√°ndo NO usar Zustand:**
- ‚ùå Estado local de un solo componente ‚Üí Usa `useState`
- ‚ùå Datos que vienen del servidor ‚Üí Usa Server Components
- ‚ùå Form state simple ‚Üí Usa `useFormState` o React Hook Form

---

### 3Ô∏è‚É£ **Client Components (app/.../page.tsx)**
**Prop√≥sito:** Interactividad, eventos, estado local

```typescript
"use client";

export default function Paso3Page() {
  // ‚úÖ DO: Estado global con Zustand (datos del formulario)
  const formData = useFormStore((state) => state.formData);
  const setAppointment = useFormStore((state) => state.setAppointment);
  
  // ‚úÖ DO: Estado local para UI (selecci√≥n temporal)
  const [selectedDate, setSelectedDate] = useState<Date>();
  const [horariosDisponibles, setHorariosDisponibles] = useState<string[]>([]);
  
  // ‚úÖ DO: useTransition para loading states (mejor que useState(loading))
  const [isPending, startTransition] = useTransition();
  
  // ‚úÖ DO: Llamar Server Actions con startTransition
  useEffect(() => {
    if (selectedDate) {
      startTransition(async () => {
        const horarios = await obtenerHorariosDisponibles(fechaStr);
        setHorariosDisponibles(horarios);
      });
    }
  }, [selectedDate]);
}
```

---

## üéØ FLUJO DE DATOS √ìPTIMO

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. USUARIO INTERACT√öA (Cliente)                     ‚îÇ
‚îÇ    - Selecciona fecha en calendario                 ‚îÇ
‚îÇ    - Evento onClick ejecuta handleDateSelect()      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. ESTADO LOCAL (Cliente - useState)                ‚îÇ
‚îÇ    - setSelectedDate(date)                          ‚îÇ
‚îÇ    - Trigger useEffect                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚Üì startTransition
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. SERVER ACTION (Servidor)                         ‚îÇ
‚îÇ    - await obtenerHorariosDisponibles(fecha)        ‚îÇ
‚îÇ    - Fetch a tu API de backend                      ‚îÇ
‚îÇ    - return horarios[]                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. ACTUALIZAR UI (Cliente)                          ‚îÇ
‚îÇ    - setHorariosDisponibles(horarios)               ‚îÇ
‚îÇ    - Re-render con nuevos horarios                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. USUARIO SELECCIONA HORA                          ‚îÇ
‚îÇ    - handleHoraSelect("09:00")                      ‚îÇ
‚îÇ    - Calcular rango con funci√≥n helper             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 6. GUARDAR EN ZUSTAND (Estado Global)              ‚îÇ
‚îÇ    - setAppointment(fecha, hora, box)               ‚îÇ
‚îÇ    - Se persiste en localStorage autom√°ticamente    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 7. NAVEGAR AL SIGUIENTE PASO                        ‚îÇ
‚îÇ    - router.push("/agendar/paso-4")                 ‚îÇ
‚îÇ    - Datos disponibles en Paso 4 v√≠a Zustand       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìù DECISIONES DE DISE√ëO

### ¬øCu√°ndo usar useState vs Zustand?

| Tipo de dato | Usar |
|--------------|------|
| Fecha seleccionada temporalmente | ‚úÖ `useState` (local) |
| Horarios disponibles (cache temporal) | ‚úÖ `useState` (local) |
| Rango de horarios visuales | ‚úÖ `useState` (local) |
| **Fecha/hora final confirmada** | ‚úÖ **Zustand** (global) |
| **Datos del usuario** | ‚úÖ **Zustand** (global) |
| **Procedimiento seleccionado** | ‚úÖ **Zustand** (global) |

### ¬øCu√°ndo usar useTransition vs useState(loading)?

```typescript
// ‚úÖ DO: useTransition (recomendado para async actions)
const [isPending, startTransition] = useTransition();

startTransition(async () => {
  const data = await serverAction();
  setData(data);
});

// Beneficios:
// - React maneja el loading state
// - No bloquea la UI
// - Cancela requests anteriores autom√°ticamente


// ‚ùå DON'T: useState(loading) - manual y propenso a errores
const [loading, setLoading] = useState(false);

setLoading(true);
const data = await serverAction();
setData(data);
setLoading(false); // ¬øY si hay error? ¬øY si el componente se desmonta?
```

---

## üöÄ OPTIMIZACIONES DE PERFORMANCE

### 1. Cache de Server Actions
```typescript
export async function obtenerHorariosDisponibles(fecha: string) {
  const response = await fetch(`https://api.com/...`, {
    next: { 
      revalidate: 30 // ‚úÖ Cache por 30 segundos
    }
  });
}
```

### 2. Selectores de Zustand
```typescript
// ‚ùå BAD: Re-render en cada cambio del store
const store = useFormStore();

// ‚úÖ GOOD: Solo re-render si formData cambia
const formData = useFormStore((state) => state.formData);

// ‚úÖ BETTER: Selectores espec√≠ficos
const procedimiento = useFormStore((state) => state.formData.procedimiento);
```

### 3. Memoizaci√≥n de c√°lculos
```typescript
// ‚úÖ Si calcularRangoHorarios es costoso
const selectedRange = useMemo(() => {
  return calcularRangoHorarios(selectedHora, duracion);
}, [selectedHora, duracion]);
```

---

## üîí SEGURIDAD

### Server Actions vs Client Fetch

```typescript
// ‚ùå INSEGURO: Expone API key/endpoint al cliente
"use client";
const data = await fetch("https://api.com/secret?key=12345");

// ‚úÖ SEGURO: Server Action oculta implementaci√≥n
"use server";
export async function getData() {
  const data = await fetch("https://api.com/secret?key=12345");
  return data;
}
```

---

## üì¶ ESTRUCTURA DE ARCHIVOS RECOMENDADA

```
app/
‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts              # ‚úÖ Server Actions de autenticaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ horarios.ts          # ‚úÖ Server Actions de horarios
‚îÇ   ‚îî‚îÄ‚îÄ citas.ts             # ‚úÖ Server Actions de citas
‚îú‚îÄ‚îÄ agendar/
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx             # Redirecci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ paso-1/page.tsx      # ‚úÖ Client Component
‚îÇ   ‚îú‚îÄ‚îÄ paso-2/page.tsx      # ‚úÖ Client Component
‚îÇ   ‚îú‚îÄ‚îÄ paso-3/page.tsx      # ‚úÖ Client Component
‚îÇ   ‚îî‚îÄ‚îÄ paso-4/page.tsx      # ‚úÖ Client Component
‚îî‚îÄ‚îÄ layout.tsx

hooks/
‚îî‚îÄ‚îÄ useFormStore.ts          # ‚úÖ Zustand store

components/
‚îî‚îÄ‚îÄ booking/
    ‚îú‚îÄ‚îÄ Stepper.tsx          # ‚úÖ Client Component
    ‚îî‚îÄ‚îÄ Calendario.tsx       # ‚úÖ Client Component

types/
‚îî‚îÄ‚îÄ index.ts                 # ‚úÖ TypeScript interfaces
```

---

## ‚úÖ CHECKLIST DE MEJORES PR√ÅCTICAS

- [x] Server Actions con `"use server"` para fetch a APIs
- [x] Zustand solo para estado compartido entre p√°ginas
- [x] `useState` para estado local de UI
- [x] `useTransition` en lugar de `useState(loading)`
- [x] Selectores espec√≠ficos de Zustand para performance
- [x] Cache con `next: { revalidate }` en fetch
- [x] TypeScript en todo el c√≥digo
- [x] Validaci√≥n antes de navegar entre pasos
- [x] Persistencia autom√°tica con Zustand + localStorage
- [x] Separaci√≥n de l√≥gica (Server) y UI (Cliente)

---

## üéì RESUMEN

**Tu implementaci√≥n actual es CORRECTA y sigue las mejores pr√°cticas de Next.js 13+:**

1. ‚úÖ **Server Actions** para datos del servidor
2. ‚úÖ **Zustand** para estado global persistente
3. ‚úÖ **useState** para estado local temporal
4. ‚úÖ **useTransition** para loading states
5. ‚úÖ **Separaci√≥n clara** entre l√≥gica y presentaci√≥n

**Ventajas vs. tu c√≥digo anterior (Vite/React):**
- üîí M√°s seguro (API keys ocultas)
- ‚ö° Mejor performance (cache autom√°tico)
- üéØ Mejor organizaci√≥n (separaci√≥n clara)
- üíæ Persistencia autom√°tica (localStorage)
- üì± Mejor UX (loading states integrados)
